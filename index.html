<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Logo Particles – Recall Loop</title>
  <style>
    html, body { margin:0; height:100%; background:#0b0d12; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; }
    .hud{
      position:fixed; left:12px; top:12px; z-index:10;
      font:12px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      color:rgba(255,255,255,.85);
      background:rgba(0,0,0,.35);
      padding:10px 12px; border:1px solid rgba(255,255,255,.12);
      border-radius:10px; backdrop-filter: blur(6px);
      max-width: 420px;
    }
    .hud b{ color:#fff; }
    .hud .row{ margin-top:6px; opacity:.9; }
    .hud code{ color:#b9d4ff; }
  </style>
</head>
<body>
  <div class="hud">
    <div><b>Logo Particles – Recall Loop</b></div>
    <div class="row">Keys: <code>R</code> rebuild mask, <code>Space</code> pause, <code>Mouse</code> swirl attract</div>
    <div class="row">Edit at top: <code>LOGO_TEXT</code>, particle count, timing, strengths.</div>
  </div>
  <canvas id="c"></canvas>

<script>
/* ===========================
   CONFIG (edit these)
=========================== */
const CONFIG = {
  LOGO_TEXT: "Just some people",          // try: "Humans&", "&&&", etc.
  FONT_FAMILY: "Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial",
  FONT_WEIGHT: 800,
  // Sampling controls (higher = fewer particles, lower = more)
  SAMPLE_STEP: 4,            // px step when sampling mask (3–7 typical)
  TARGET_PARTICLES: 3600,    // will try to get close to this count

  // Particle appearance
  PARTICLE_RADIUS: 1.45,
  PARTICLE_ALPHA: 0.85,

  // Free physics
  FLOW_STRENGTH: 0.65,       // 0..2
  FLOW_SCALE: 0.0032,        // noise scale
  DRAG: 0.985,               // velocity damping
  SPEED_LIMIT: 3.25,

  // Particle-to-particle separation (reduce “ropes”)
  SEPARATION: true,
  SEP_RADIUS: 10,            // interaction radius
  SEP_STRENGTH: 0.18,        // 0..1

  // Soft boundary around the whole logo mask (keeps them near the mark)
  MASK_BOUNDARY: true,
  MASK_BOUNDARY_STRENGTH: 0.06, // 0..0.3

  // Loop timing (seconds)
  LOOP: {
    FREE: 2.6,
    RECALL: 1.3,
    HOLD: 0.55,
    RELEASE: 0.55,
  },

  // Recall behavior
  RECALL_STRENGTH: 0.030,    // spring strength to home
  RECALL_DAMP: 0.86,         // additional damping during recall
  HOLD_LERP: 0.30,           // snap-to-home during hold

  // Release burst
  RELEASE_BURST: 1.4,        // add random + outward velocity
  RELEASE_OUTWARD: 0.9,      // outward from center

  // Mouse swirl
  MOUSE_SWIRL: true,
  MOUSE_STRENGTH: 1.25,
  MOUSE_RADIUS: 220,
};

/* ===========================
   CANVAS SETUP
=========================== */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d", { alpha: true });

let W = 0, H = 0, DPR = Math.min(2, window.devicePixelRatio || 1);
function resize(){
  DPR = Math.min(2, window.devicePixelRatio || 1);
  W = Math.floor(window.innerWidth);
  H = Math.floor(window.innerHeight);
  canvas.width = Math.floor(W * DPR);
  canvas.height = Math.floor(H * DPR);
  canvas.style.width = W + "px";
  canvas.style.height = H + "px";
  ctx.setTransform(DPR,0,0,DPR,0,0);
  buildMaskAndParticles();
}
window.addEventListener("resize", resize);

/* ===========================
   SIMPLE 2D NOISE (fast)
=========================== */
function hash(n){ return (Math.sin(n) * 43758.5453123) % 1; }
function noise2(x,y){
  const xi = Math.floor(x), yi = Math.floor(y);
  const xf = x - xi, yf = y - yi;
  const n00 = hash((xi*15731 + yi*789221) | 0);
  const n10 = hash(((xi+1)*15731 + yi*789221) | 0);
  const n01 = hash((xi*15731 + (yi+1)*789221) | 0);
  const n11 = hash(((xi+1)*15731 + (yi+1)*789221) | 0);
  const u = xf*xf*(3-2*xf);
  const v = yf*yf*(3-2*yf);
  const x1 = n00*(1-u) + n10*u;
  const x2 = n01*(1-u) + n11*u;
  return x1*(1-v) + x2*v;
}

/* ===========================
   MASK BUILD (text -> points)
=========================== */
let particles = [];
let maskBounds = { minX:0, minY:0, maxX:0, maxY:0, cx:0, cy:0 };

function buildMaskAndParticles(){
  // offscreen canvas to rasterize text
  const off = document.createElement("canvas");
  const octx = off.getContext("2d");
  off.width = Math.floor(W);
  off.height = Math.floor(H);

  // choose font size based on viewport
  const base = Math.min(W, H);
  const fontSize = Math.max(96, Math.floor(base * 0.22));
  octx.clearRect(0,0,off.width,off.height);
  octx.fillStyle = "#fff";
  octx.textAlign = "center";
  octx.textBaseline = "middle";
  octx.font = `${CONFIG.FONT_WEIGHT} ${fontSize}px ${CONFIG.FONT_FAMILY}`;

  // draw centered
  const x0 = off.width/2;
  const y0 = off.height/2;
  octx.fillText(CONFIG.LOGO_TEXT, x0, y0);

  // read pixels and sample mask points
  const img = octx.getImageData(0,0,off.width,off.height);
  const data = img.data;

  const step = CONFIG.SAMPLE_STEP;
  const pts = [];
  let minX=1e9, minY=1e9, maxX=-1e9, maxY=-1e9;

  // First pass: gather all candidate points
  for(let y=0; y<off.height; y+=step){
    for(let x=0; x<off.width; x+=step){
      const i = (y*off.width + x)*4 + 3; // alpha
      const a = data[i];
      if(a > 50){
        pts.push({x, y});
        if(x<minX) minX=x;
        if(y<minY) minY=y;
        if(x>maxX) maxX=x;
        if(y>maxY) maxY=y;
      }
    }
  }
  if(!pts.length){
    particles = [];
    return;
  }

  maskBounds = {
    minX, minY, maxX, maxY,
    cx: (minX+maxX)/2,
    cy: (minY+maxY)/2
  };

  // Downsample/upsample to TARGET_PARTICLES
  let homes = pts;
  const target = CONFIG.TARGET_PARTICLES;
  if(homes.length > target){
    // random pick
    const picked = [];
    for(let i=0;i<target;i++){
      const j = (Math.random()*homes.length) | 0;
      picked.push(homes[j]);
    }
    homes = picked;
  } else if(homes.length < target){
    // duplicate with jitter
    const expanded = homes.slice();
    while(expanded.length < target){
      const p = homes[(Math.random()*homes.length)|0];
      expanded.push({ x: p.x + (Math.random()-0.5)*step, y: p.y + (Math.random()-0.5)*step });
    }
    homes = expanded;
  }

  // Create particles with home position AND current position initially at home
  particles = homes.map((p, idx) => ({
    id: idx,
    homeX: p.x,
    homeY: p.y,
    x: p.x,
    y: p.y,
    vx: (Math.random()-0.5)*0.2,
    vy: (Math.random()-0.5)*0.2,
    r: CONFIG.PARTICLE_RADIUS * (0.85 + Math.random()*0.3),
  }));
}

/* ===========================
   LOOP STATE MACHINE
=========================== */
const modes = { FREE:0, RECALL:1, HOLD:2, RELEASE:3 };
let mode = modes.FREE;
let t = 0;
let loopTotal = CONFIG.LOOP.FREE + CONFIG.LOOP.RECALL + CONFIG.LOOP.HOLD + CONFIG.LOOP.RELEASE;

function updateMode(dt){
  t += dt;
  if(t >= loopTotal) t -= loopTotal;

  const a = CONFIG.LOOP.FREE;
  const b = a + CONFIG.LOOP.RECALL;
  const c = b + CONFIG.LOOP.HOLD;
  const d = c + CONFIG.LOOP.RELEASE;

  if(t < a) mode = modes.FREE;
  else if(t < b) mode = modes.RECALL;
  else if(t < c) mode = modes.HOLD;
  else mode = modes.RELEASE;
}

/* ===========================
   MOUSE
=========================== */
const mouse = { x:0, y:0, down:false, moved:false };
window.addEventListener("pointermove", (e) => {
  mouse.x = e.clientX; mouse.y = e.clientY; mouse.moved = true;
});
window.addEventListener("pointerdown", () => mouse.down = true);
window.addEventListener("pointerup", () => mouse.down = false);

/* ===========================
   SPATIAL GRID for separation
=========================== */
let grid = null;
function buildGrid(){
  const cellSize = Math.max(6, CONFIG.SEP_RADIUS);
  const cols = Math.ceil(W / cellSize);
  const rows = Math.ceil(H / cellSize);
  grid = { cellSize, cols, rows, cells: new Array(cols*rows) };
  for(let i=0;i<grid.cells.length;i++) grid.cells[i] = [];
  for(const p of particles){
    const cx = Math.max(0, Math.min(cols-1, (p.x / cellSize) | 0));
    const cy = Math.max(0, Math.min(rows-1, (p.y / cellSize) | 0));
    grid.cells[cy*cols + cx].push(p);
  }
}
function neighbors(p){
  const { cellSize, cols, rows, cells } = grid;
  const cx = Math.max(0, Math.min(cols-1, (p.x / cellSize) | 0));
  const cy = Math.max(0, Math.min(rows-1, (p.y / cellSize) | 0));
  const out = [];
  for(let oy=-1; oy<=1; oy++){
    for(let ox=-1; ox<=1; ox++){
      const nx = cx+ox, ny = cy+oy;
      if(nx>=0 && nx<cols && ny>=0 && ny<rows){
        const bucket = cells[ny*cols + nx];
        for(let i=0;i<bucket.length;i++) out.push(bucket[i]);
      }
    }
  }
  return out;
}

/* ===========================
   UPDATE PHYSICS
=========================== */
function clampSpeed(p){
  const sp = Math.hypot(p.vx, p.vy);
  if(sp > CONFIG.SPEED_LIMIT){
    const s = CONFIG.SPEED_LIMIT / sp;
    p.vx *= s; p.vy *= s;
  }
}

function applyMaskBoundary(p){
  if(!CONFIG.MASK_BOUNDARY) return;
  const pad = 6; // soft padding
  const bx0 = maskBounds.minX - pad, by0 = maskBounds.minY - pad;
  const bx1 = maskBounds.maxX + pad, by1 = maskBounds.maxY + pad;
  let fx = 0, fy = 0;

  if(p.x < bx0) fx += (bx0 - p.x);
  else if(p.x > bx1) fx -= (p.x - bx1);

  if(p.y < by0) fy += (by0 - p.y);
  else if(p.y > by1) fy -= (p.y - by1);

  p.vx += fx * CONFIG.MASK_BOUNDARY_STRENGTH;
  p.vy += fy * CONFIG.MASK_BOUNDARY_STRENGTH;
}

function applySeparation(p){
  if(!CONFIG.SEPARATION || !grid) return;
  const neigh = neighbors(p);
  const R = CONFIG.SEP_RADIUS;
  const R2 = R*R;
  let fx = 0, fy = 0, count = 0;

  for(const q of neigh){
    if(q === p) continue;
    const dx = p.x - q.x;
    const dy = p.y - q.y;
    const d2 = dx*dx + dy*dy;
    if(d2 > 0 && d2 < R2){
      const d = Math.sqrt(d2);
      const s = (R - d) / R; // stronger when closer
      fx += (dx / d) * s;
      fy += (dy / d) * s;
      count++;
    }
  }
  if(count){
    p.vx += (fx / count) * CONFIG.SEP_STRENGTH;
    p.vy += (fy / count) * CONFIG.SEP_STRENGTH;
  }
}

function applyMouseSwirl(p){
  if(!CONFIG.MOUSE_SWIRL || !mouse.moved) return;
  const dx = p.x - mouse.x;
  const dy = p.y - mouse.y;
  const d = Math.hypot(dx, dy);
  if(d < CONFIG.MOUSE_RADIUS){
    // swirl: perpendicular force + mild attraction when mouse down
    const t = 1 - (d / CONFIG.MOUSE_RADIUS);
    const perpX = -dy / (d + 1e-6);
    const perpY =  dx / (d + 1e-6);
    const swirl = CONFIG.MOUSE_STRENGTH * t * 0.25;
    p.vx += perpX * swirl;
    p.vy += perpY * swirl;

    if(mouse.down){
      const attr = CONFIG.MOUSE_STRENGTH * t * 0.20;
      p.vx += (-dx / (d + 1e-6)) * attr;
      p.vy += (-dy / (d + 1e-6)) * attr;
    }
  }
}

function updateParticles(dt){
  // separation grid only really needed during FREE/RELEASE
  if(CONFIG.SEPARATION && (mode === modes.FREE || mode === modes.RELEASE)) buildGrid();

  for(const p of particles){
    if(mode === modes.FREE){
      // flow field
      const nx = p.x * CONFIG.FLOW_SCALE;
      const ny = p.y * CONFIG.FLOW_SCALE;
      const ang = noise2(nx, ny) * Math.PI * 2;
      p.vx += Math.cos(ang) * CONFIG.FLOW_STRENGTH * 0.15;
      p.vy += Math.sin(ang) * CONFIG.FLOW_STRENGTH * 0.15;

      applySeparation(p);
      applyMaskBoundary(p);
      applyMouseSwirl(p);

      // integrate
      p.vx *= Math.pow(CONFIG.DRAG, dt*60);
      p.vy *= Math.pow(CONFIG.DRAG, dt*60);
      clampSpeed(p);
      p.x += p.vx * dt * 60;
      p.y += p.vy * dt * 60;

    } else if(mode === modes.RECALL){
      // spring to home (smooth regroup)
      const dx = p.homeX - p.x;
      const dy = p.homeY - p.y;
      p.vx += dx * CONFIG.RECALL_STRENGTH;
      p.vy += dy * CONFIG.RECALL_STRENGTH;

      // extra damping so they settle cleanly
      p.vx *= CONFIG.RECALL_DAMP;
      p.vy *= CONFIG.RECALL_DAMP;

      clampSpeed(p);
      p.x += p.vx * dt * 60;
      p.y += p.vy * dt * 60;

    } else if(mode === modes.HOLD){
      // snap gently to home + kill velocity
      p.x += (p.homeX - p.x) * CONFIG.HOLD_LERP;
      p.y += (p.homeY - p.y) * CONFIG.HOLD_LERP;
      p.vx *= 0.35;
      p.vy *= 0.35;

    } else if(mode === modes.RELEASE){
      // one-time kick right as release starts (small window)
      // We detect "first frames" of release by using t position in loop.
      // Simple: apply small noise every frame but scaled.
      const dxC = p.x - maskBounds.cx;
      const dyC = p.y - maskBounds.cy;
      const d = Math.hypot(dxC, dyC) + 1e-6;

      // outward + random burst
      const burst = CONFIG.RELEASE_BURST * 0.06;
      p.vx += (dxC / d) * CONFIG.RELEASE_OUTWARD * burst;
      p.vy += (dyC / d) * CONFIG.RELEASE_OUTWARD * burst;
      p.vx += (Math.random()-0.5) * burst;
      p.vy += (Math.random()-0.5) * burst;

      // still allow mild flow + separation so it looks alive
      const nx = p.x * CONFIG.FLOW_SCALE;
      const ny = p.y * CONFIG.FLOW_SCALE;
      const ang = noise2(nx, ny) * Math.PI * 2;
      p.vx += Math.cos(ang) * CONFIG.FLOW_STRENGTH * 0.08;
      p.vy += Math.sin(ang) * CONFIG.FLOW_STRENGTH * 0.08;

      applySeparation(p);
      applyMaskBoundary(p);
      applyMouseSwirl(p);

      p.vx *= Math.pow(CONFIG.DRAG, dt*60);
      p.vy *= Math.pow(CONFIG.DRAG, dt*60);
      clampSpeed(p);
      p.x += p.vx * dt * 60;
      p.y += p.vy * dt * 60;
    }

    // keep inside canvas (soft wrap)
    if(p.x < -50) p.x = W + 50;
    if(p.x > W + 50) p.x = -50;
    if(p.y < -50) p.y = H + 50;
    if(p.y > H + 50) p.y = -50;
  }
}

/* ===========================
   RENDER
=========================== */
function draw(){
  ctx.clearRect(0,0,W,H);

  // subtle vignette background
  const g = ctx.createRadialGradient(W*0.5,H*0.5, Math.min(W,H)*0.1, W*0.5,H*0.5, Math.min(W,H)*0.8);
  g.addColorStop(0, "rgba(255,255,255,0.02)");
  g.addColorStop(1, "rgba(0,0,0,0.25)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);

  // particles
  ctx.globalAlpha = CONFIG.PARTICLE_ALPHA;
  ctx.fillStyle = "rgba(255,255,255,1)";
  for(const p of particles){
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // optional: show mask boundary (debug)
  // ctx.strokeStyle = "rgba(255,255,255,0.15)";
  // ctx.strokeRect(maskBounds.minX, maskBounds.minY, maskBounds.maxX-maskBounds.minX, maskBounds.maxY-maskBounds.minY);
}

/* ===========================
   MAIN LOOP
=========================== */
let last = performance.now();
let paused = false;

function frame(now){
  const dt = Math.min(0.05, (now - last) / 1000);
  last = now;

  if(!paused && particles.length){
    updateMode(dt);
    updateParticles(dt);
  }
  draw();
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

/* ===========================
   CONTROLS
=========================== */
window.addEventListener("keydown", (e) => {
  if(e.code === "Space"){
    paused = !paused;
    e.preventDefault();
  }
  if(e.key.toLowerCase() === "r"){
    buildMaskAndParticles();
  }
});

// start
resize();
</script>
</body>
</html>