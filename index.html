<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Humans&-ish Particles (Auto-Tuned Airy+Solid)</title>
  <style>
    html, body { margin:0; width:100%; height:100%; overflow:hidden; background:#0b0b0f; }
    canvas { display:block; position:fixed; inset:0; width:100%; height:100%; }

    .ui {
      position:fixed; top:12px; right:12px; z-index:5;
      display:flex; gap:8px;
      font:13px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      user-select:none;
    }
    .btn{
      border:0; border-radius:10px;
      padding:9px 12px; cursor:pointer;
      background:#ffd65a; color:#0b0b0f;
    }
    .btn.secondary{
      background:rgba(255,255,255,.14);
      color:rgba(255,255,255,.9);
      border:1px solid rgba(255,255,255,.16);
    }
    .label{
      position:fixed; left:12px; top:12px; z-index:5;
      font:13px/1.3 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color:rgba(255,255,255,.82);
      background:rgba(0,0,0,.35);
      padding:8px 10px; border-radius:12px;
      backdrop-filter: blur(10px);
      max-width:min(92vw, 980px);
    }
    .label small { opacity:.75; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="label" id="label">
    Humans&-ish particles seeded inside a bold <b>&amp;&amp;&amp;</b> mask with interpersonal aura + torus flow.
    Density is auto-tuned to stay “airy + solid” across screen sizes.
    <small>Toggle Guide to see the mask. Repulsion affects dissimilar “tribes”.</small>
  </div>

  <div class="ui">
    <button class="btn secondary" id="repelBtn">Repulsion: On</button>
    <button class="btn secondary" id="guideBtn">Guide: Off</button>
    <button class="btn" id="resetBtn">Reset</button>
  </div>

<script>
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false });
  const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  // ====== MASK TEXT ======
  const LOGO_TEXT = "just some people";
  // =======================

  // --- Visual ---
  const BG_FADE = 0.18;       // higher = faster fade = fewer streaks
  let DOT_R = 2.0;            // auto-tuned in seed()
  const MAX_DPR = 2;

  // --- Mask sampling ---
  const MASK_ALPHA = 55;
  const SAMPLE_STRIDE = 2;    // higher resolution for ampersand loops
  const MASK_CELL = 26;

  // Gentle tether: keeps wordmark coherent
  const MASK_TETHER = 0.040;
  const MASK_FALLOFF = 0.020;

  // --- Boundary around the mask (flow-friendly containment) ---
  const BOUNDARY_WIDTH = 18;    // distance (px) from nearest hub considered "inside enough"
  const BOUNDARY_FORCE = 0.045; // gentle inward correction (no slamming)
  const EDGE_SLIDE = 0.28;      // tangential assist along edges (preserves swirl)

  // --- Social dynamics ---
  const NEI_R = 26;
  const NEI_R2 = NEI_R * NEI_R;

  const DRAG = 0.988;
  const JITTER = prefersReducedMotion ? 0.02 : 0.038;

  const ALIGN = 0.008;       // low alignment reduces filaments
  const COHESION = 0.028;    // centroid cohesion produces “blobs”
  const SEPARATION = 0.012;  // weak macro separation; aura does micro spacing
  const REPULSE = 0.018;     // dissimilar repulsion (toggle)

  // similarity weight strength
  const SIM_K = 6.0;

  // --- Humans& interpersonal aura (soft personal bubble) ---
  // These are slightly tuned dynamically based on density in seed()
  let AURA_RADIUS = 6.2;
  let AURA_FORCE = 0.032;

  // --- Global torus flow (stable spiral / donut circulation) ---
  const FLOW_SWIRL = 0.018;      // around-center orbital drift
  const FLOW_POLAR = 0.010;      // in/out circulation (through donut)
  const FLOW_FREQ = 2.0;         // “donut” character
  const FLOW_SPEED = 0.85;       // time speed
  const FLOW_TANGENT_MIX = 0.35; // poloidal tangent component

  // --- Fake 3D depth (subtle) ---
  const DEPTH_STRENGTH = 0.55;   // dot radius changes with depth

  // --- Auto-tune density (airy + solid) ---
  const TARGET_COVERAGE = 0.84;  // 0.80–0.86 = airy+solid balance
  const DOT_R_MIN = 1.7;
  const DOT_R_MAX = 2.2;
  const N_MIN = 1800;
  const N_MAX = 5200;

  let W = 0, H = 0, dpr = 1;

  let hubs = [];
  let maskArea = 0;        // approximate mask area in px^2 (from sampling)
  let guideCanvas = null;
  const hubGrid = new Map();

  const agents = [];
  const neiGrid = new Map();

  let repulsionOn = true;
  let showGuide = false;

  function gridKey(x, y, cell) {
    return `${Math.floor(x / cell)},${Math.floor(y / cell)}`;
  }

  function clearFrame() {
    ctx.fillStyle = "#0b0b0f";
    ctx.fillRect(0, 0, W, H);
  }

  function buildMask() {
    const off = document.createElement('canvas');
    off.width = W;
    off.height = H;
    const o = off.getContext('2d');

    o.clearRect(0, 0, W, H);
    o.fillStyle = "#fff";
    o.textAlign = "center";
    o.textBaseline = "middle";

    const baseSize = Math.max(72, Math.min(210, W * 0.20));
    o.font = `900 ${baseSize * 1.08}px system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
    o.fillText(LOGO_TEXT, W * 0.5, H * 0.52);

    const img = o.getImageData(0, 0, W, H).data;

    hubs = [];
    let maskAreaApprox = 0;

    for (let y = 0; y < H; y += SAMPLE_STRIDE) {
      for (let x = 0; x < W; x += SAMPLE_STRIDE) {
        const a = img[(y * W + x) * 4 + 3];
        if (a > MASK_ALPHA) {
          hubs.push({ x, y });
          maskAreaApprox += (SAMPLE_STRIDE * SAMPLE_STRIDE);
        }
      }
    }

    maskArea = maskAreaApprox;

    hubGrid.clear();
    for (const p of hubs) {
      const k = gridKey(p.x, p.y, MASK_CELL);
      const bucket = hubGrid.get(k);
      if (bucket) bucket.push(p);
      else hubGrid.set(k, [p]);
    }

    guideCanvas = off;
  }

  function findNearestHub(x, y) {
    if (!hubs.length) return null;

    const cx = Math.floor(x / MASK_CELL);
    const cy = Math.floor(y / MASK_CELL);

    let best = null;
    let bestD2 = Infinity;

    for (let gy = cy - 2; gy <= cy + 2; gy++) {
      for (let gx = cx - 2; gx <= cx + 2; gx++) {
        const bucket = hubGrid.get(`${gx},${gy}`);
        if (!bucket) continue;
        for (const p of bucket) {
          const dx = p.x - x;
          const dy = p.y - y;
          const d2 = dx * dx + dy * dy;
          if (d2 < bestD2) {
            bestD2 = d2;
            best = p;
          }
        }
      }
    }
    return best;
  }

  function seed() {
    agents.length = 0;
    if (!hubs.length || maskArea <= 0) return;

    // --- Auto-tune DOT_R and N for airy+solid coverage ---
    const screenScale = Math.min(1.15, Math.max(0.9, (W * H) / (1100 * 700)));
    DOT_R = Math.max(DOT_R_MIN, Math.min(DOT_R_MAX, 1.9 * screenScale));

    const dotArea = Math.PI * DOT_R * DOT_R;
    let desiredN = Math.round((TARGET_COVERAGE * maskArea) / dotArea);

    desiredN = Math.max(N_MIN, Math.min(N_MAX, desiredN));
    desiredN = Math.min(desiredN, Math.floor(hubs.length * 0.92)); // keep some breathing room

    // Relax aura slightly if density rises (prevents “packed” look)
    const density = desiredN / 2800;
    AURA_RADIUS = 6.2 - Math.max(0, density - 1) * 0.6; // down to ~5.6
    AURA_FORCE  = 0.032 - Math.max(0, density - 1) * 0.006; // down to ~0.026

    // expose for debugging if you want
    window.__TUNED_N = desiredN;
    window.__DOT_R = DOT_R;

    const n = Math.min(desiredN, hubs.length);

    for (let i = 0; i < n; i++) {
      const p = hubs[(Math.random() * hubs.length) | 0];
      agents.push({
        x: p.x + (Math.random() - 0.5) * 2,
        y: p.y + (Math.random() - 0.5) * 2,
        vx: (Math.random() - 0.5) * 0.18,
        vy: (Math.random() - 0.5) * 0.18,
        t: Math.random(),
        hub: p,
        z: Math.random()
      });
    }
  }

  // Neighbor grid
  function rebuildNeighbors() {
    neiGrid.clear();
    for (const a of agents) {
      const k = gridKey(a.x, a.y, NEI_R);
      const bucket = neiGrid.get(k);
      if (bucket) bucket.push(a);
      else neiGrid.set(k, [a]);
    }
  }

  function neighbors(a, fn) {
    const cx = Math.floor(a.x / NEI_R);
    const cy = Math.floor(a.y / NEI_R);

    for (let gy = cy - 1; gy <= cy + 1; gy++) {
      for (let gx = cx - 1; gx <= cx + 1; gx++) {
        const bucket = neiGrid.get(`${gx},${gy}`);
        if (!bucket) continue;

        for (const b of bucket) {
          if (b === a) continue;
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const d2 = dx * dx + dy * dy;
          if (d2 <= NEI_R2) fn(b, dx, dy, Math.sqrt(d2));
        }
      }
    }
  }

  function smoothstep01(t) {
    return t * t * (3 - 2 * t);
  }

  // Global torus-like flow field + subtle fake depth
  function addTorusFlow(a) {
    const cx = W * 0.5;
    const cy = H * 0.52;

    const dx = a.x - cx;
    const dy = a.y - cy;

    const r = Math.hypot(dx, dy) || 1;
    const nx = dx / r;
    const ny = dy / r;

    // tangent for orbit swirl
    const tx = -ny;
    const ty = nx;

    const angle = Math.atan2(dy, dx);
    const time = performance.now() * 0.001;

    // torus phase: angle + time + trait offset
    const phase = time * FLOW_SPEED + angle * FLOW_FREQ + a.t * Math.PI * 2;

    // poloidal: in/out + slight tangent
    const pr = Math.sin(phase);
    const pt = Math.cos(phase) * FLOW_TANGENT_MIX;

    a.vx += tx * FLOW_SWIRL + nx * (pr * FLOW_POLAR) + tx * (pt * FLOW_POLAR);
    a.vy += ty * FLOW_SWIRL + ny * (pr * FLOW_POLAR) + ty * (pt * FLOW_POLAR);

    // depth cue synced with phase
    a.z = 0.5 + 0.5 * Math.sin(phase);
  }

  function update() {
    rebuildNeighbors();

    for (const a of agents) {
      // base motion
      a.vx *= DRAG;
      a.vy *= DRAG;

      a.vx += (Math.random() - 0.5) * JITTER;
      a.vy += (Math.random() - 0.5) * JITTER;

      // global spiral / torus flow
      addTorusFlow(a);

      // forces
      let ax = 0, ay = 0;

      // alignment + centroid cohesion
      let avx = 0, avy = 0, vCount = 0;
      let cx = 0, cy = 0, cCount = 0;

      neighbors(a, (b, dx, dy, d) => {
        const nx = dx / d;
        const ny = dy / d;

        const sim = Math.exp(-SIM_K * Math.abs(a.t - b.t));

        // macro separation
        const sep = SEPARATION / (1 + d * 0.25);
        ax -= nx * sep;
        ay -= ny * sep;

        // interpersonal aura (soft bubble)
        if (d < AURA_RADIUS) {
          const t = 1 - (d / AURA_RADIUS);
          const soft = smoothstep01(t);
          const push = soft * AURA_FORCE;
          ax -= nx * push;
          ay -= ny * push;
        }

        // alignment among similar
        avx += b.vx * sim;
        avy += b.vy * sim;
        vCount += sim;

        // centroid cohesion among similar
        cx += b.x * sim;
        cy += b.y * sim;
        cCount += sim;

        // dissimilar repulsion (tribe separation)
        if (repulsionOn) {
          const dis = 1 - sim;
          const rep = (dis * REPULSE) / (1 + d * 0.25);
          ax -= nx * rep;
          ay -= ny * rep;
        }
      });

      if (vCount > 0.001) {
        avx /= vCount;
        avy /= vCount;
        a.vx += (avx - a.vx) * ALIGN;
        a.vy += (avy - a.vy) * ALIGN;
      }

      if (cCount > 0.001) {
        cx /= cCount;
        cy /= cCount;
        const dx = cx - a.x;
        const dy = cy - a.y;
        const d = Math.hypot(dx, dy) || 1;
        a.vx += (dx / d) * COHESION;
        a.vy += (dy / d) * COHESION;
      }

      // --- Mask tether + flow-friendly boundary containment ---
      if (!a.hub || Math.random() < 0.01) a.hub = findNearestHub(a.x, a.y);

      if (a.hub) {
        const dx = a.hub.x - a.x;
        const dy = a.hub.y - a.y;
        const dist = Math.hypot(dx, dy) || 0.0001;
        const nx = dx / dist;
        const ny = dy / dist;

        // gentle tether
        const tether = MASK_TETHER / (1 + dist * MASK_FALLOFF);
        ax += nx * tether;
        ay += ny * tether;

        // boundary: cancel outward leakage but keep tangential swirl
        if (dist > BOUNDARY_WIDTH) {
          const over = dist - BOUNDARY_WIDTH;

          // If moving outward (away from hub), remove that component
          const vDotN = a.vx * nx + a.vy * ny;
          if (vDotN < 0) {
            a.vx -= vDotN * nx;
            a.vy -= vDotN * ny;
          }

          // gentle inward correction force
          const push = over * BOUNDARY_FORCE;
          ax += nx * push;
          ay += ny * push;

          // tiny tangential assist along boundary
          const tx = -ny;
          const ty = nx;
          a.vx += tx * (EDGE_SLIDE * 0.01);
          a.vy += ty * (EDGE_SLIDE * 0.01);
        }
      }

      // apply forces
      a.vx += ax;
      a.vy += ay;

      // integrate
      a.x += a.vx;
      a.y += a.vy;

      // keep on screen (soft bounce)
      if (a.x < 0) { a.x = 0; a.vx = Math.abs(a.vx) * 0.6; }
      if (a.x > W) { a.x = W; a.vx = -Math.abs(a.vx) * 0.6; }
      if (a.y < 0) { a.y = 0; a.vy = Math.abs(a.vy) * 0.6; }
      if (a.y > H) { a.y = H; a.vy = -Math.abs(a.vy) * 0.6; }
    }
  }

  function draw() {
    // trails
    ctx.fillStyle = `rgba(11,11,15,${BG_FADE})`;
    ctx.fillRect(0, 0, W, H);

    // optional guide overlay
    if (showGuide && guideCanvas) {
      ctx.save();
      ctx.globalAlpha = 0.06;
      ctx.drawImage(guideCanvas, 0, 0);
      ctx.restore();
    }

    // two-pass depth draw for subtle 3D feel
    ctx.fillStyle = "#ffd65a";

    // back
    ctx.beginPath();
    for (const a of agents) {
      if (a.z > 0.5) continue;
      const r = DOT_R * (0.75 + a.z * DEPTH_STRENGTH);
      ctx.moveTo(a.x + r, a.y);
      ctx.arc(a.x, a.y, r, 0, Math.PI * 2);
    }
    ctx.fill();

    // front
    ctx.beginPath();
    for (const a of agents) {
      if (a.z <= 0.5) continue;
      const r = DOT_R * (0.75 + a.z * DEPTH_STRENGTH);
      ctx.moveTo(a.x + r, a.y);
      ctx.arc(a.x, a.y, r, 0, Math.PI * 2);
    }
    ctx.fill();
  }

  function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
  }

  function resize() {
    dpr = Math.max(1, Math.min(MAX_DPR, window.devicePixelRatio || 1));
    W = innerWidth;
    H = innerHeight;

    canvas.width = Math.floor(W * dpr);
    canvas.height = Math.floor(H * dpr);
    canvas.style.width = W + "px";
    canvas.style.height = H + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    buildMask();
    seed();
    clearFrame();
  }

  // UI
  document.getElementById('resetBtn').addEventListener('click', () => {
    seed();
    clearFrame();
  });

  document.getElementById('guideBtn').addEventListener('click', (e) => {
    showGuide = !showGuide;
    e.target.textContent = `Guide: ${showGuide ? 'On' : 'Off'}`;
  });

  document.getElementById('repelBtn').addEventListener('click', (e) => {
    repulsionOn = !repulsionOn;
    e.target.textContent = `Repulsion: ${repulsionOn ? 'On' : 'Off'}`;
  });

  window.addEventListener('resize', resize);

  // Init
  resize();
  requestAnimationFrame(loop);
</script>
</body>
</html>