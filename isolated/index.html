<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Happy Face Split - Auto Fill Mask</title>
  <style>
    html, body { margin:0; width:100%; height:100%; overflow:hidden; background:#0b0b0f; }
    canvas { display:block; width:100%; height:100vh; position:fixed; inset:0; }
    .hint {
      position:fixed; left:12px; top:12px; z-index:3;
      font:14px/1.3 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      color:rgba(255,255,255,.86);
      background:rgba(0,0,0,.35);
      padding:8px 10px; border-radius:12px;
      backdrop-filter:blur(10px);
      user-select:none;
      transition:opacity .6s ease;
    }
    .hint.fade-out { opacity:0; pointer-events:none; }
    .controls { position:fixed; right:12px; top:12px; z-index:3; display:flex; gap:8px; }
    .btn {
      font:13px/1.2 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      color:#0b0b0f; background:#ffd65a; border:0;
      border-radius:10px; padding:9px 12px; cursor:pointer;
    }
    .btn.secondary { background:rgba(255,255,255,.14); color:rgba(255,255,255,.9); border:1px solid rgba(255,255,255,.16); }
    .btn:hover { filter:brightness(1.05); }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="hint" id="hint">Click the face once to begin.</div>
  <div class="controls">
    <button class="btn secondary" id="pauseBtn">Pause</button>
    <button class="btn" id="resetBtn">Reset</button>
  </div>

<script>
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });
  const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  // --- Constants ---
  const BASE_RADIUS = 120;
  const PEER_CELL = 72;
  const HUB_CELL = 28;
  const ATTRACT_THRESHOLD_ALPHA = 70;

  // Growth / physics
  let SHRINK = 0.78;
  let SEP = 1.15;
  let SPLIT_MS = 520;
  let DRAG = 0.992;
  let JIGGLE = prefersReducedMotion ? 0.01 : 0.055;

  // Autopilot controls
  const MAX_POP = 240;               // hard cap safety
  const MIN_RADIUS = 9;              // don’t split below this
  const SPLITS_PER_SEC_BASE = 4.0;   // pacing baseline
  const SPLITS_PER_SEC_MAX  = 12.0;  // pacing when we’re close to done

  // Coverage target
  const COVERAGE_TARGET = 0.78;      // % of hubs "occupied"
  const COVERAGE_SAMPLE = 900;       // sample hubs for speed
  const HUB_OCCUPY_DIST = 18;        // how close a cell needs to be to count

  // --- State ---
  const cells = [];
  const splits = [];
  const peerGrid = new Map();
  const textHubGrid = new Map();
  let textHubs = [];
  let guideCanvas = null;

  let hasStarted = false;
  let paused = false;
  let autoMode = false;
  let autoAccumulator = 0;
  let lastT = performance.now();

  function gridKey(x, y, cellSize) {
    return `${Math.floor(x / cellSize)},${Math.floor(y / cellSize)}`;
  }

  function buildTextAttractionMask() {
    const off = document.createElement('canvas');
    off.width = innerWidth;
    off.height = innerHeight;
    const octx = off.getContext('2d');

    octx.clearRect(0, 0, off.width, off.height);
    octx.fillStyle = '#fff';
    octx.textAlign = 'center';
    octx.textBaseline = 'middle';

    const fontSize = Math.max(42, Math.min(110, innerWidth * 0.075));
    octx.font = `800 ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
    octx.fillText('Just some people', off.width * 0.5, off.height * 0.52);

    const img = octx.getImageData(0, 0, off.width, off.height).data;
    const stride = Math.max(3, Math.floor(fontSize / 16));

    textHubs = [];
    for (let y = 0; y < off.height; y += stride) {
      for (let x = 0; x < off.width; x += stride) {
        const a = img[(y * off.width + x) * 4 + 3];
        if (a > ATTRACT_THRESHOLD_ALPHA) textHubs.push({ x, y });
      }
    }

    textHubGrid.clear();
    for (const p of textHubs) {
      const k = gridKey(p.x, p.y, HUB_CELL);
      const bucket = textHubGrid.get(k);
      if (bucket) bucket.push(p);
      else textHubGrid.set(k, [p]);
    }

    return off;
  }

  function safeBuildTextAttractionMask() {
    try { guideCanvas = buildTextAttractionMask(); }
    catch (e) { guideCanvas = null; textHubs = []; textHubGrid.clear(); }
  }

  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width = `${innerWidth}px`;
    canvas.style.height = `${innerHeight}px`;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    safeBuildTextAttractionMask();
  }

  function findNearestHub(x, y, maxRing = 4) {
    if (!textHubs.length) return null;
    const cx = Math.floor(x / HUB_CELL), cy = Math.floor(y / HUB_CELL);
    let best = null, bestD2 = Infinity;

    for (let ring = 0; ring <= maxRing; ring++) {
      let found = false;
      for (let gy = cy - ring; gy <= cy + ring; gy++) {
        for (let gx = cx - ring; gx <= cx + ring; gx++) {
          const bucket = textHubGrid.get(`${gx},${gy}`);
          if (!bucket) continue;
          found = true;
          for (const p of bucket) {
            const dx = p.x - x, dy = p.y - y;
            const d2 = dx*dx + dy*dy;
            if (d2 < bestD2) { bestD2 = d2; best = p; }
          }
        }
      }
      if (found && best) break;
    }
    return best;
  }

  function rebuildPeerGrid() {
    peerGrid.clear();
    for (const cell of cells) {
      const k = gridKey(cell.x, cell.y, PEER_CELL);
      const b = peerGrid.get(k);
      if (b) b.push(cell);
      else peerGrid.set(k, [cell]);
    }
  }

  function getNearbyPeers(cell, radius = 110) {
    const out = [];
    const cr = Math.ceil(radius / PEER_CELL);
    const cx = Math.floor(cell.x / PEER_CELL), cy = Math.floor(cell.y / PEER_CELL);
    const r2 = radius * radius;

    for (let gy = cy - cr; gy <= cy + cr; gy++) {
      for (let gx = cx - cr; gx <= cx + cr; gx++) {
        const bucket = peerGrid.get(`${gx},${gy}`);
        if (!bucket) continue;
        for (const other of bucket) {
          if (other === cell) continue;
          const dx = other.x - cell.x, dy = other.y - cell.y;
          if (dx*dx + dy*dy <= r2) out.push(other);
        }
      }
    }
    return out;
  }

  function addCell(x, y, r, parent = null) {
    const inheritedVx = parent ? parent.vx * 0.55 : 0;
    const inheritedVy = parent ? parent.vy * 0.55 : 0;
    const hub = findNearestHub(x, y);
    cells.push({
      x, y, r,
      vx: inheritedVx + (Math.random() - 0.5) * 0.45,
      vy: inheritedVy + (Math.random() - 0.5) * 0.55,
      individuality: Math.random() * 0.35,
      hub,
      hubT: performance.now()
    });
  }

  function reset() {
    cells.length = 0;
    splits.length = 0;
    hasStarted = false;
    autoMode = false;
    autoAccumulator = 0;
    paused = false;
    lastT = performance.now();

    addCell(innerWidth * 0.5, innerHeight * 0.5, BASE_RADIUS);

    document.getElementById('hint')?.classList.remove('fade-out');
    document.getElementById('pauseBtn').textContent = 'Pause';

    ctx.fillStyle = '#0b0b0f';
    ctx.fillRect(0, 0, innerWidth, innerHeight);
  }

  function drawFace(x, y, r) {
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = '#ffd65a';
    ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();

    const eyeY = -r * 0.22;
    const eyeX = r * 0.3;
    const eyeR = Math.max(1.4, r * 0.08);
    ctx.fillStyle = '#0b0b0f';
    ctx.beginPath();
    ctx.arc(-eyeX, eyeY, eyeR, 0, Math.PI*2);
    ctx.arc( eyeX, eyeY, eyeR, 0, Math.PI*2);
    ctx.fill();

    ctx.strokeStyle = '#0b0b0f';
    ctx.lineWidth = Math.max(1.4, r * 0.08);
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.arc(0, r*0.02, r*0.42, 0.2*Math.PI, 0.8*Math.PI);
    ctx.stroke();
    ctx.restore();
  }

  function startSplit(cell) {
    if (!cell) return;
    if (cell.r < MIN_RADIUS) return;

    const i = cells.indexOf(cell);
    if (i === -1) return;
    cells.splice(i, 1);

    const angle = Math.random() * Math.PI * 2;
    const sep = cell.r * SEP;
    const newR = cell.r * SHRINK;
    const speed = 1.25;

    const hub = cell.hub || findNearestHub(cell.x, cell.y);
    let biasX = 0, biasY = 0;
    if (hub) {
      const dx = hub.x - cell.x, dy = hub.y - cell.y;
      const d = Math.hypot(dx, dy) || 1;
      biasX = (dx / d) * 0.35;
      biasY = (dy / d) * 0.35;
    }

    const c1 = {
      x: cell.x + Math.cos(angle) * sep,
      y: cell.y + Math.sin(angle) * sep,
      r: newR,
      vx: cell.vx * 0.55 + Math.cos(angle) * speed + biasX,
      vy: cell.vy * 0.55 + Math.sin(angle) * speed + biasY,
      individuality: Math.random() * 0.35,
      hub: null, hubT: 0
    };
    const c2 = {
      x: cell.x - Math.cos(angle) * sep,
      y: cell.y - Math.sin(angle) * sep,
      r: newR,
      vx: cell.vx * 0.55 - Math.cos(angle) * speed + biasX,
      vy: cell.vy * 0.55 - Math.sin(angle) * speed + biasY,
      individuality: Math.random() * 0.35,
      hub: null, hubT: 0
    };

    c1.hub = findNearestHub(c1.x, c1.y); c1.hubT = performance.now();
    c2.hub = findNearestHub(c2.x, c2.y); c2.hubT = performance.now();

    splits.push({
      start: performance.now(),
      c1a: { x: cell.x, y: cell.y }, c1b: c1,
      c2a: { x: cell.x, y: cell.y }, c2b: c2
    });

    cells.push(c1, c2);

    if (!hasStarted) {
      hasStarted = true;
      document.getElementById('hint')?.classList.add('fade-out');
    }
  }

  // --- Coverage estimation: are enough hubs occupied? ---
  function estimateMaskCoverage() {
    if (!textHubs.length || !cells.length) return 0;

    // sample hub points evenly-ish
    const n = Math.min(COVERAGE_SAMPLE, textHubs.length);
    const step = Math.floor(textHubs.length / n);

    const dist2 = HUB_OCCUPY_DIST * HUB_OCCUPY_DIST;
    let hit = 0;

    // quick/naive check: for each sampled hub, see if any cell is near it
    // (fast enough at these sizes; if you push MAX_POP huge, we can grid this too)
    for (let i = 0; i < textHubs.length; i += step) {
      const h = textHubs[i];
      let ok = false;
      for (let j = 0; j < cells.length; j++) {
        const c = cells[j];
        const dx = c.x - h.x, dy = c.y - h.y;
        if (dx*dx + dy*dy <= dist2) { ok = true; break; }
      }
      if (ok) hit++;
    }
    return hit / n;
  }

  // --- Choose which cell to split next (UX: pick the ones that help fill the mask) ---
  function chooseSplitCandidate() {
    if (!cells.length) return null;

    // prefer larger cells (more "mass") + those farther from their hub
    let best = null;
    let bestScore = -Infinity;

    for (const c of cells) {
      if (c.r < MIN_RADIUS) continue;

      // refresh hub occasionally
      const t = performance.now();
      if (!c.hub || (t - c.hubT) > 320) {
        c.hub = findNearestHub(c.x, c.y, 4);
        c.hubT = t;
      }

      let d = 140; // default
      if (c.hub) d = Math.hypot(c.hub.x - c.x, c.hub.y - c.y);

      const sizeScore = c.r;                 // bigger = better candidate
      const farScore = Math.min(240, d);     // farther from hub = more useful to split
      const score = sizeScore * 0.9 + farScore * 0.35;

      if (score > bestScore) { bestScore = score; best = c; }
    }
    return best;
  }

  function applySocialSteering(cell, population) {
    // wander
    const wanderX = (Math.random() - 0.5) * JIGGLE;
    const wanderY = (Math.random() - 0.5) * JIGGLE;

    // peer alignment
    let alignX = 0, alignY = 0;
    const peers = getNearbyPeers(cell, 105);
    if (peers.length) {
      let avgVx = 0, avgVy = 0;
      for (const p of peers) { avgVx += p.vx; avgVy += p.vy; }
      avgVx /= peers.length; avgVy /= peers.length;
      alignX = (avgVx - cell.vx) * 0.03;
      alignY = (avgVy - cell.vy) * 0.03;
    }

    // hub refresh
    const t = performance.now();
    if (!cell.hub || (t - cell.hubT) > 320) {
      cell.hub = findNearestHub(cell.x, cell.y, 4);
      cell.hubT = t;
    }

    // text attraction
    let attractX = 0, attractY = 0;
    const resistChance = 0.08 + cell.individuality * 0.35;

    if (Math.random() > resistChance && cell.hub) {
      const hub = cell.hub;
      const dx = hub.x - cell.x, dy = hub.y - cell.y;
      const dist = Math.hypot(dx, dy) || 1;
      const nx = dx / dist, ny = dy / dist;

      const popBoost = Math.min(1.35, 0.45 + population / 26);
      const sizeBoost = Math.min(2.1, BASE_RADIUS / Math.max(12, cell.r));
      const falloff = 1 / (1 + dist * 0.03);
      const strength = 0.018 * popBoost * sizeBoost * falloff;

      attractX = nx * strength;
      attractY = ny * strength;
    }

    cell.vx += wanderX + alignX * 0.65 + attractX * 0.4;
    cell.vy += wanderY + alignY * 0.65 + attractY * 0.4;
  }

  function step(now) {
    const dt = Math.min(0.05, (now - lastT) / 1000);
    lastT = now;

    if (!paused) {
      // trails
      ctx.fillStyle = 'rgba(11,11,15,0.06)';
      ctx.fillRect(0, 0, innerWidth, innerHeight);

      // split animations
      for (let i = splits.length - 1; i >= 0; i--) {
        const s = splits[i];
        const p = Math.min(1, (now - s.start) / SPLIT_MS);
        const c1x = s.c1a.x + (s.c1b.x - s.c1a.x) * p;
        const c1y = s.c1a.y + (s.c1b.y - s.c1a.y) * p;
        const c2x = s.c2a.x + (s.c2b.x - s.c2a.x) * p;
        const c2y = s.c2a.y + (s.c2b.y - s.c2a.y) * p;
        drawFace(c1x, c1y, s.c1b.r);
        drawFace(c2x, c2y, s.c2b.r);
        if (p >= 1) splits.splice(i, 1);
      }

      rebuildPeerGrid();

      // physics update
      for (const cell of cells) {
        cell.vx *= DRAG;
        cell.vy *= DRAG;
        applySocialSteering(cell, cells.length);
        cell.x += cell.vx;
        cell.y += cell.vy;

        // bounds
        if (cell.x - cell.r < 0) { cell.x = cell.r; cell.vx = Math.abs(cell.vx) * 0.6; }
        if (cell.x + cell.r > innerWidth) { cell.x = innerWidth - cell.r; cell.vx = -Math.abs(cell.vx) * 0.6; }
        if (cell.y - cell.r < 0) { cell.y = cell.r; cell.vy = Math.abs(cell.vy) * 0.6; }
        if (cell.y + cell.r > innerHeight) { cell.y = innerHeight - cell.r; cell.vy = -Math.abs(cell.vy) * 0.6; }

        drawFace(cell.x, cell.y, cell.r);
      }

      // --- Autopilot splitting ---
      if (autoMode) {
        const coverage = estimateMaskCoverage();

        // ramp splitting speed as we get close (so it "locks in" faster)
        const speed = SPLITS_PER_SEC_BASE + (SPLITS_PER_SEC_MAX - SPLITS_PER_SEC_BASE) * Math.min(1, Math.max(0, (coverage - 0.35) / 0.45));
        autoAccumulator += dt * speed;

        // stop if done
        if (coverage >= COVERAGE_TARGET || cells.length >= MAX_POP) {
          autoMode = false;
        } else {
          while (autoAccumulator >= 1) {
            autoAccumulator -= 1;
            const candidate = chooseSplitCandidate();
            if (!candidate) { autoMode = false; break; }
            startSplit(candidate);
            if (cells.length >= MAX_POP) { autoMode = false; break; }
          }
        }
      }
    }

    requestAnimationFrame(step);
  }

  // one click starts everything
  window.addEventListener('pointerdown', (e) => {
    if (paused) return;

    // Only first click matters: start autopilot
    if (!autoMode) {
      autoMode = true;
      hasStarted = true;
      document.getElementById('hint')?.classList.add('fade-out');
    }
  }, { passive: true });

  document.getElementById('resetBtn').addEventListener('click', reset);
  document.getElementById('pauseBtn').addEventListener('click', () => {
    paused = !paused;
    document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
  });

  window.addEventListener('resize', resize);

  resize();
  reset();
  requestAnimationFrame(step);
</script>
</body>
</html>